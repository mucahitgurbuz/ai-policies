import type { CompositionMetadata } from '@ai-policies/core-schemas';
import type { CursorProviderOptions } from './cursor-provider.js';
import { generateTableOfContents, cleanupWhitespace } from './formatter.js';

export interface CursorTemplateContext {
  content: string;
  metadata: CompositionMetadata;
  options: Required<CursorProviderOptions>;
}

/**
 * Generate Cursor rules using the default template
 */
export function generateCursorTemplate(context: CursorTemplateContext): string {
  const { content, metadata, options } = context;

  const sections: string[] = [];

  // Add metadata header (already included in content)
  // Content already contains the metadata header from composition

  // Add table of contents if content is substantial
  if (content.length > 2000 && options.includeCategories) {
    const toc = generateTableOfContents(content);
    if (toc) {
      sections.push(toc);
    }
  }

  // Add main content
  sections.push(content);

  // Add footer with attribution if enabled
  if (options.includeAttribution) {
    sections.push(generateAttribution(metadata));
  }

  // Combine and clean up
  const combined = sections.join('\\n\\n');
  return cleanupWhitespace(combined);
}

/**
 * Generate attribution section
 */
function generateAttribution(metadata: CompositionMetadata): string {
  const packagesList = Object.entries(metadata.packages)
    .map(([name, version]) => \`- \${name}@\${version}\`)
    .join('\\n');

  return \`---

## Generated by AI Policies

This file was automatically generated from the following policy packages:

\${packagesList}

**Generated at**: \${new Date(metadata.generatedAt).toLocaleString()}
**Content hash**: \`\${metadata.contentHash}\`

> Do not edit this file directly. Use \`ai-policies sync\` to regenerate.\`;
}

/**
 * Create a minimal Cursor rules template
 */
export function createMinimalTemplate(rules: string[]): string {
  const basicRules = [
    '# AI Assistant Rules',
    '',
    '## Core Guidelines',
    '',
    ...rules.map(rule => \`- \${rule}\`),
    '',
    '## Security',
    '',
    '- Never expose API keys, passwords, or sensitive data',
    '- Always validate user input',
    '- Use secure coding practices',
  ];

  return basicRules.join('\\n');
}

/**
 * Create a comprehensive Cursor rules template
 */
export function createComprehensiveTemplate(context: {
  coreRules: string[];
  securityRules: string[];
  codeQualityRules: string[];
  projectSpecificRules?: string[];
}): string {
  const sections: string[] = [];

  sections.push('# AI Assistant Rules');
  sections.push('');
  sections.push('This file contains rules and guidelines for AI code assistance.');
  sections.push('');

  // Core rules
  sections.push('## Core Guidelines');
  sections.push('');
  context.coreRules.forEach(rule => {
    sections.push(\`- \${rule}\`);
  });
  sections.push('');

  // Security rules
  sections.push('## Security Requirements');
  sections.push('');
  sections.push('> **Critical**: These security rules must always be followed.');
  sections.push('');
  context.securityRules.forEach(rule => {
    sections.push(\`- \${rule}\`);
  });
  sections.push('');

  // Code quality rules
  sections.push('## Code Quality Standards');
  sections.push('');
  context.codeQualityRules.forEach(rule => {
    sections.push(\`- \${rule}\`);
  });
  sections.push('');

  // Project-specific rules
  if (context.projectSpecificRules && context.projectSpecificRules.length > 0) {
    sections.push('## Project-Specific Guidelines');
    sections.push('');
    context.projectSpecificRules.forEach(rule => {
      sections.push(\`- \${rule}\`);
    });
    sections.push('');
  }

  return sections.join('\\n');
}

/**
 * Template for React projects
 */
export function createReactTemplate(): string {
  return \`# React Project AI Rules

## Component Development

- Use functional components with hooks instead of class components
- Implement proper PropTypes or TypeScript interfaces
- Follow the single responsibility principle for components
- Use meaningful component and prop names

## State Management

- Use useState for local component state
- Use useContext for shared state between components
- Consider useReducer for complex state logic
- Avoid prop drilling; use context when needed

## Performance

- Use React.memo for expensive components
- Implement useCallback and useMemo appropriately
- Lazy load components when beneficial
- Avoid creating objects/functions in render methods

## Security

- Sanitize user input before rendering
- Use dangerouslySetInnerHTML sparingly and safely
- Validate props at component boundaries
- Avoid exposing sensitive data in client-side code

## Testing

- Write unit tests for components
- Test user interactions and edge cases
- Use React Testing Library for component testing
- Mock external dependencies in tests\`;
}

/**
 * Template for Node.js backend projects
 */
export function createNodeBackendTemplate(): string {
  return \`# Node.js Backend AI Rules

## API Development

- Use consistent RESTful API patterns
- Implement proper HTTP status codes
- Validate request data using schemas
- Handle errors gracefully with appropriate responses

## Security

- Implement authentication and authorization
- Use HTTPS in production
- Sanitize and validate all inputs
- Implement rate limiting
- Never log sensitive information

## Database

- Use parameterized queries to prevent SQL injection
- Implement proper connection pooling
- Use transactions for related operations
- Index frequently queried fields

## Error Handling

- Use try-catch blocks appropriately
- Log errors with sufficient context
- Return user-friendly error messages
- Implement global error handlers

## Performance

- Implement caching strategies
- Use async/await for asynchronous operations
- Monitor memory usage and prevent leaks
- Optimize database queries\`;
}
