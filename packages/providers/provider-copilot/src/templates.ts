import type { CompositionMetadata } from '@ai-policies/core-schemas';
import type { CopilotProviderOptions } from './copilot-provider.js';
import { generatePromptTemplates, generateSafetyConstraints, optimizeForCopilot } from './formatter.js';

export interface CopilotTemplateContext {
  content: string;
  metadata: CompositionMetadata;
  options: Required<CopilotProviderOptions>;
}

/**
 * Generate Copilot instructions using the default template
 */
export function generateCopilotTemplate(context: CopilotTemplateContext): string {
  const { content, metadata, options } = context;

  const sections: string[] = [];

  // Add header with project context
  sections.push(generateHeader());

  // Add organization guidelines if provided
  if (options.organizationGuidelines.length > 0) {
    sections.push(generateOrganizationGuidelines(options.organizationGuidelines));
  }

  // Add main content
  sections.push(content);

  // Add safety constraints if enabled
  if (options.includeSafetyConstraints) {
    sections.push(generateSafetyConstraints());
  }

  // Add prompt templates if enabled
  if (options.includePromptTemplates) {
    sections.push(generatePromptTemplates());
  }

  // Add code examples section if enabled
  if (options.includeCodeExamples) {
    sections.push(generateCodeExamplesSection());
  }

  // Add footer with metadata
  sections.push(generateFooter(metadata));

  // Combine and optimize
  const combined = sections.join('\\n\\n');
  return optimizeForCopilot(combined);
}

/**
 * Generate header section
 */
function generateHeader(): string {
  return \`# GitHub Copilot Instructions

This document provides guidelines and instructions for GitHub Copilot to assist with code generation and suggestions in this project.

## Overview

These instructions help Copilot understand:
- Project-specific coding standards and patterns
- Security requirements and constraints
- Preferred libraries and frameworks
- Team coding conventions\`;
}

/**
 * Generate organization guidelines section
 */
function generateOrganizationGuidelines(guidelines: string[]): string {
  const formattedGuidelines = guidelines
    .map(guideline => \`- \${guideline}\`)
    .join('\\n');

  return \`## Organization Guidelines

\${formattedGuidelines}\`;
}

/**
 * Generate code examples section
 */
function generateCodeExamplesSection(): string {
  return \`## Code Examples

### Preferred Function Structure
\`\`\`typescript
// Good: Clear function with proper typing and documentation
/**
 * Processes user data according to business requirements
 * @param userData - The user data to process
 * @returns Processed user data
 */
export async function processUserData(userData: UserData): Promise<ProcessedData> {
  // Validate input
  if (!userData || !userData.id) {
    throw new Error('Invalid user data provided');
  }

  try {
    // Process data
    const result = await performProcessing(userData);
    return result;
  } catch (error) {
    logger.error('Failed to process user data', { error, userId: userData.id });
    throw error;
  }
}
\`\`\`

### Error Handling Pattern
\`\`\`typescript
// Good: Comprehensive error handling
try {
  const result = await riskyOperation();
  return { success: true, data: result };
} catch (error) {
  // Log error with context
  logger.error('Operation failed', {
    operation: 'riskyOperation',
    error: error.message,
    stack: error.stack
  });

  // Return user-friendly error
  return {
    success: false,
    error: 'Operation could not be completed. Please try again.'
  };
}
\`\`\`

### API Response Structure
\`\`\`typescript
// Good: Consistent API response format
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  timestamp: string;
}

// Usage
app.get('/api/users/:id', async (req, res) => {
  try {
    const user = await getUserById(req.params.id);
    res.json({
      success: true,
      data: user,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve user',
      timestamp: new Date().toISOString()
    });
  }
});
\`\`\`\`;
}

/**
 * Generate footer with metadata
 */
function generateFooter(metadata: CompositionMetadata): string {
  const packagesList = Object.entries(metadata.packages)
    .map(([name, version]) => \`- \${name}@\${version}\`)
    .join('\\n');

  return \`---

## Document Information

**Generated by**: AI Policies
**Generated at**: \${new Date(metadata.generatedAt).toLocaleString()}
**Content hash**: \`\${metadata.contentHash}\`

### Policy Packages Used
\${packagesList}

> This file is automatically generated. To modify these instructions, update your policy packages and run \`ai-policies sync\`.\`;
}

/**
 * Create a framework-specific template
 */
export function createFrameworkTemplate(framework: 'react' | 'vue' | 'angular' | 'express' | 'nestjs'): string {
  const templates = {
    react: \`# React Project Guidelines for Copilot

## Component Patterns
- Use functional components with hooks
- Implement TypeScript interfaces for props
- Follow component naming conventions (PascalCase)
- Use custom hooks for reusable logic

## State Management
- Use useState for local state
- Use useContext for shared state
- Consider useReducer for complex state logic
- Implement proper dependency arrays in useEffect

## Performance
- Use React.memo for expensive components
- Implement useCallback and useMemo appropriately
- Lazy load components when beneficial
- Avoid creating objects in render methods\`,

    vue: \`# Vue.js Project Guidelines for Copilot

## Component Structure
- Use Composition API with \`<script setup>\`
- Implement proper TypeScript types
- Follow single-file component structure
- Use proper component naming (kebab-case in templates)

## Reactivity
- Use ref() for primitive values
- Use reactive() for objects
- Implement computed properties for derived state
- Use watch/watchEffect appropriately\`,

    angular: \`# Angular Project Guidelines for Copilot

## Component Architecture
- Use OnPush change detection strategy
- Implement proper lifecycle hooks
- Use standalone components when appropriate
- Follow Angular style guide conventions

## Dependency Injection
- Use constructor injection
- Implement proper service structure
- Use providedIn: 'root' for singleton services
- Implement proper error handling\`,

    express: \`# Express.js Guidelines for Copilot

## Route Structure
- Use proper middleware organization
- Implement consistent error handling
- Use route-specific validation
- Follow RESTful conventions

## Security
- Implement proper authentication middleware
- Use helmet.js for security headers
- Validate and sanitize all inputs
- Implement rate limiting\`,

    nestjs: \`# NestJS Guidelines for Copilot

## Module Organization
- Follow modular architecture
- Use proper dependency injection
- Implement DTOs for data validation
- Use guards for authentication/authorization

## Controllers
- Keep controllers thin
- Use proper decorators
- Implement swagger documentation
- Handle errors with exception filters\`
  };

  return templates[framework];
}

/**
 * Create a simple template for basic projects
 */
export function createSimpleTemplate(): string {
  return \`# Project Guidelines for GitHub Copilot

## General Principles
- Write clean, readable, and maintainable code
- Follow established patterns and conventions
- Include appropriate comments and documentation
- Implement proper error handling

## Security
- Never expose sensitive information
- Validate all user inputs
- Use secure coding practices
- Follow the principle of least privilege

## Code Quality
- Use meaningful variable and function names
- Keep functions small and focused
- Avoid code duplication
- Write tests for critical functionality\`;
}

/**
 * Create a comprehensive enterprise template
 */
export function createEnterpriseTemplate(options: {
  companyName: string;
  frameworks: string[];
  securityLevel: 'standard' | 'high' | 'critical';
}): string {
  const securitySection = options.securityLevel === 'critical'
    ? \`## Critical Security Requirements
- All code must undergo security review
- Implement zero-trust architecture principles
- Use approved cryptographic libraries only
- Follow SOC 2 compliance requirements\`
    : \`## Security Requirements
- Follow security best practices
- Implement proper authentication
- Use HTTPS for all communications
- Validate and sanitize inputs\`;

  const frameworkSection = options.frameworks.length > 0
    ? \`## Approved Frameworks
- \${options.frameworks.join('\\n- ')}\`
    : '';

  return \`# \${options.companyName} Development Guidelines

## Company Standards
These guidelines ensure consistency across all \${options.companyName} development projects.

\${securitySection}

\${frameworkSection}

## Code Review Requirements
- All code must be reviewed before merging
- Follow company coding standards
- Include appropriate tests
- Update documentation as needed

## Compliance
- Follow company data handling policies
- Implement required audit logging
- Ensure accessibility compliance
- Meet performance benchmarks\`;
}
